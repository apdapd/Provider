Добрый день.

Получив задание и посмотрев задачи сразу возникло следующее соображение. 

Задача 3 для реализации требует большего знания теории хранения данных SQL-серверами. В данный момент я это знаю недостаточно хорошо, чтобы браться за подобные вещи. Ибо большую часть времени работы с данными я все эти вещи использовал как обычный пользователь. Да, кое-что о способах хранения данных, индексов, версионности и т.п. мне известно, но знаний этих недостаточно в даннй момент для профессиональной работы в этом направлении. При необходимости можно заняться и изучить, но для этого требуется время.

Задача 2 показалась достаточно простой и выполнимой. С базами данных работать приходилось давно и долго, ещё с dbf-формата FoxPro и далее. Единственный момент - работа с web-приложениями для меня тоже пока в новинку, но общие идеи ясны и очевидны.
Задачча 1 показалась наиболее интереснй и не требовала особых знаний работы с интерефейсом пользователя, что для меня тоже некоторый плюс. Однако, посвятив некоторое время поискам и выясниениям обстоятельств, что же было сделано ранее в этом направлении, узнал много нового.  

Первым найденным оказался https://github.com/nycdotnet/TSqlFlex.SqlParser. Вещь внешне весьма эффектная, с кучей распараллеливаний, но не дающая описанного результата. Как мне кажется, выложена не самая последняя версия, в связи с чем работает не так, как заявлено. Впрочем, в данном случае строка разбирается на запчасти не совсем грамотно и вопрос о дальнейшем использовании весьма неясен.

Потом я нашёл весьма неплохую вещь, о которой неоднократно упоминается в контексте обсуждения SQL-парсеров. http://www.codeproject.com/Articles/32524/SQL-Parser от Sergey Gorbenko. Правда и тут не без ошибок, в частости неверная реакция на поля, названия котрых начинаются с ключевых слов и точка с запятой в конце запроса не переносится в случае дополнения условием упорядочивания, но эти вещи достаточно просто исправляются.

Следующим открытием стало http://irony.codeplex.com. Тут уж вообще мощный парсер языков со своей грамматикой для каждого, в частности есть пример для SQL. И написано весьма толково, с построеним дерева разбора исходной строки... 

Далее, коммерческий вариант http://www.sqlparser.com предоставляет схему распарсивания сложных выражений с несколькими таблицами( http://www.sqlparser.com/docs/How_to_use_join_table.html). Но он платный.

Ну и последнее открытие много мне объяснило, почему все эти вещи заканчивалмсь 2012 годом. https://msdn.microsoft.com/en-us/library/microsoft.data.schema.scriptdom.sql.tsqlparser(v=vs.100) Думаю, с этим мне вряд ли потягаться...


Впрочем, поразмыслив и сопоставив 1 и 3 задачи, я всё же решил попробовать написать парсер. Правда, для скорости попытался использовать работу Gorbenko, она с одной стороны не слишком мудрёная, с другой - как раз как надо разбирает всё выражение на составляющие строки. А уж потом строки разложить на отдельные выражения вроде не так уж и сложно. Но в процессе всего этоно прошло время. Потом у меня просто выпала неделя и в результате время прошло, работа не сделана. 

В итоге решил сделать вторую задачу чтобы хоть что-то показать. Основная идея реализации - попытка отделить интерфейс пользователя от обработки даннных. Это, как мне кажется, позволит к имеющейся логике и механизмам обработки данных почти безболезненно приделать другой интерфейс пользователя. Хотя, может я и ошибаюсь...
База сделана в MS SQL, это то, что в данный момент у меня стоит и устойчиво работает. Опыты с MySQL у меня были примерно год назад, в ближайшие дни поставлю MySQL сервер и переделаю программу под него. 

Я, конечно, понимаю, что времени прошло много, результат почти никакой... Но не отвечать это не не совсем правильно с моей точки зрения.


Докучаев А.П.